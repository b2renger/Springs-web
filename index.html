<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Interactive Springs</title>
  <style>
    html, body {
      padding: 0;
      margin: 0;
      overflow: hidden; /* Prevent scrollbars and bouncing */
      height: 100%;
      -webkit-font-smoothing: antialiased;
      background-color: #000; /* Match canvas background */
    }
    canvas {
      display: block;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
</head>
<body>
  <main></main>
  <script>
    // @license
    // SPDX-License-Identifier: Apache-2.0

    // --- Configuration ---
    const NUM_BOBS = 8;
    const MIN_GAP = 5; // Minimum gap between bobs and from screen edge

    // --- Musical Scales ---
    const scales = {
        'Major': [0, 2, 4, 5, 7, 9, 11],
        'Natural Minor': [0, 2, 3, 5, 7, 8, 10],
        'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11],
        'Dorian': [0, 2, 3, 5, 7, 9, 10],
        'Mixolydian': [0, 2, 4, 5, 7, 9, 10],
        'Blues': [0, 3, 5, 6, 7, 10],
        'Phrygian': [0, 1, 3, 5, 7, 8, 10],
        'Pentatonic Major': [0, 2, 4, 7, 9],
        'Chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
        'Whole Tone': [0, 2, 4, 6, 8, 10],
    };

    // --- Simulation Parameters (controlled by GUI) ---
    const settings = {
        stiffness: 0.2,
        damping: 0.92,
        velocitySmoothing: 0.0,
        mass: 20,
        baseMidiNote: 48, // C3
        selectedScale: 'Major',
        oscillatorType: 'sine',
    };
    const effectSettings = {
        reverbEnabled: false,
        reverbMix: 0.5,
        reverbDecay: 3,
        distortionEnabled: false,
        distortionAmount: 0.25,
        distortionMix: 0.5,
    };

    // --- Global State ---
    let bobs = [];
    let springs = [];
    // A map to keep track of which input (by id) is dragging which bob.
    const draggedItems = new Map();
    let audioInitialized = false;
    let gui;
    let reverb, distortion, fft;

    // --- Classes ---

    // Represents a single oscillating bob (the circle)
    class Bob {
      constructor(x, y, freq, radius) {
        this.position = createVector(x, y);
        this.velocity = createVector(0, 0);
        this.smoothedVelocity = createVector(0, 0);
        this.acceleration = createVector(0, 0);
        this.mass = settings.mass;
        this.radius = radius;
        this.isDragging = false;
        
        // --- Audio Setup ---
        this.osc = new p5.Oscillator(settings.oscillatorType);
        this.osc.freq(freq);
        this.osc.amp(0);
        
        // Connect to the effects chain
        this.osc.disconnect();
        this.osc.connect(distortion);
        
        this.osc.start();
      }

      // Apply a force to the bob
      applyForce(force) {
        let f = p5.Vector.div(force, this.mass);
        this.acceleration.add(f);
      }

      // Update the bob's physics state
      update() {
        if (!this.isDragging) {
          this.velocity.add(this.acceleration);
          this.velocity.mult(settings.damping); // Use dynamic damping

          // Apply additional velocity smoothing for a less jittery motion
          const smoothingFactor = 1.0 - settings.velocitySmoothing;
          this.smoothedVelocity.lerp(this.velocity, smoothingFactor);
          
          this.position.add(this.smoothedVelocity); // Use smoothed velocity
          this.acceleration.mult(0); // Reset acceleration for the next frame
        }
      }

      // Draw the bob on the canvas
      display() {
        stroke(255);
        strokeWeight(2);
        fill(255);
        ellipse(this.position.x, this.position.y, this.radius * 2, this.radius * 2);
      }

      // Check if a point (x, y) is inside the bob
      isOver(x, y) {
        return dist(x, y, this.position.x, this.position.y) < this.radius;
      }
    }

    // Represents a spring connecting a static anchor point to a bob
    class Spring {
      constructor(anchor, bob, restLength) {
        this.anchor = anchor; // p5.Vector
        this.bob = bob;       // Bob object
        this.restLength = restLength;
        this.stiffness = settings.stiffness;
      }

      // Calculate and apply the spring force to the bob
      update() {
        // Calculate the vertical displacement from the rest length
        let displacement = this.bob.position.y - this.anchor.y;
        let stretch = displacement - this.restLength;

        // Apply Hooke's Law: F = -k * x
        let forceY = -1 * this.stiffness * stretch;
        this.bob.applyForce(createVector(0, forceY));
      }

      // Draw the spring and its anchor point
      display() {
        // Draw the anchor
        fill(100);
        noStroke();
        ellipse(this.anchor.x, this.anchor.y, 10, 10);

        // Draw the spring line
        stroke(200, 150);
        strokeWeight(2);
        line(this.anchor.x, this.anchor.y, this.bob.position.x, this.bob.position.y);
      }
    }

    // --- P5.js Core Functions ---

    function setup() {
      createCanvas(windowWidth, windowHeight);
      
      // --- Audio Effects Setup ---
      distortion = new p5.Distortion();
      reverb = new p5.Reverb();
      fft = new p5.FFT();
      
      // Chain: distortion -> reverb -> master output
      distortion.disconnect(); // Disconnect from master to connect to reverb
      distortion.connect(reverb);
      
      setupSimulation(true); // Full reset

      // --- GUI Setup ---
      gui = new lil.GUI();
      
      const physicsFolder = gui.addFolder('Physics');
      physicsFolder.add(settings, 'stiffness', 0.01, 1.0).onChange(value => {
        for (const spring of springs) {
            spring.stiffness = value;
        }
      });
      physicsFolder.add(settings, 'damping', 0.8, 1.0);
      physicsFolder.add(settings, 'velocitySmoothing', 0, 0.99).name('Smoothing');
      physicsFolder.add(settings, 'mass', 1, 100).onChange(value => {
        for (const bob of bobs) {
            bob.mass = value;
        }
      });
      
      const audioFolder = gui.addFolder('Audio');
      audioFolder.add(settings, 'baseMidiNote', 36, 72, 1).name('Base MIDI Note').onChange(() => setupSimulation());
      audioFolder.add(settings, 'selectedScale', Object.keys(scales)).name('Scale').onChange(() => setupSimulation());
      audioFolder.add(settings, 'oscillatorType', ['sine', 'sawtooth', 'square']).name('Waveform').onChange(value => {
        for (const bob of bobs) {
            if (bob.osc) {
                bob.osc.setType(value);
            }
        }
      });

      // --- Effects GUI ---
      const effectsFolder = gui.addFolder('Effects');
      
      const reverbFolder = effectsFolder.addFolder('Reverb');
      reverbFolder.add(effectSettings, 'reverbEnabled').name('Enabled').onChange(value => {
        reverb.drywet(value ? effectSettings.reverbMix : 0);
      });
      reverbFolder.add(effectSettings, 'reverbMix', 0, 1).name('Mix').onChange(value => {
        if (effectSettings.reverbEnabled) {
          reverb.drywet(value);
        }
      });
      reverbFolder.add(effectSettings, 'reverbDecay', 0, 10).name('Decay').onChange(value => {
        reverb.set(value);
      });
      
      const distortionFolder = effectsFolder.addFolder('Distortion');
      distortionFolder.add(effectSettings, 'distortionEnabled').name('Enabled').onChange(value => {
        distortion.drywet(value ? effectSettings.distortionMix : 0);
      });
      distortionFolder.add(effectSettings, 'distortionAmount', 0, 1).name('Amount').onChange(value => {
        distortion.set(value, '2x');
      });
      distortionFolder.add(effectSettings, 'distortionMix', 0, 1).name('Mix').onChange(value => {
         if (effectSettings.distortionEnabled) {
          distortion.drywet(value);
        }
      });
      
      // Initialize effect states based on settings
      reverb.set(effectSettings.reverbDecay);
      reverb.drywet(effectSettings.reverbEnabled ? effectSettings.reverbMix : 0);
      distortion.set(effectSettings.distortionAmount, '2x');
      distortion.drywet(effectSettings.distortionEnabled ? effectSettings.distortionMix : 0);
    }
    
    function draw() {
      background(0);

      // --- Physics & Audio Updates ---
      for (const spring of springs) {
        spring.update();
        // spring.display(); // Do not draw the spring or anchor
        
        const bob = spring.bob;
        const distance = abs(bob.position.y - spring.anchor.y);
        
        let normalizedDistance = map(distance, 0, height / 2, 0, 1);
        normalizedDistance = constrain(normalizedDistance, 0, 1);

        let volume = Math.pow(normalizedDistance, 2) * 0.15;
        
        if (bob.osc) {
            bob.osc.amp(volume, 0.05);
        }
      }

      // --- Bob Drawing ---
      for (const bob of bobs) {
        bob.update();
        bob.display();
      }
      
      // --- Waveform Visualization (Drawn on top) ---
      fft.analyze();
      const waveform = fft.waveform();
      const waveformWidth = width * 0.8;
      const waveformHeight = 600;
      const startX = (width - waveformWidth) / 2;
      const centerY = height / 2;

      noStroke();
      fill(230, 80, 80); // A warm red

      const barWidth = waveformWidth / waveform.length;
      for (let i = 0; i < waveform.length; i++) {
        const x = startX + (i * barWidth);
        const h = map(abs(waveform[i]), 0, 1, 0, waveformHeight);
        const y = centerY - h / 2;
        rect(x, y, barWidth, h);
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      setupSimulation(true); // Full reset
    }
    
    // --- Input Handling ---

    function startAudio() {
        if (!audioInitialized && getAudioContext().state !== 'running') {
            userStartAudio();
            audioInitialized = true;
        }
    }

    function startDrag(x, y, id) {
      for (let i = bobs.length - 1; i >= 0; i--) {
        const bob = bobs[i];
        if (bob.isOver(x, y) && !draggedItems.has(id)) {
          bob.isDragging = true;
          bob.position.y = y;
          draggedItems.set(id, bob);
          return true;
        }
      }
      return false;
    }

    function moveDrag(x, y, id) {
        const draggedBob = draggedItems.get(id);
        if (draggedBob) {
            draggedBob.position.y = y;
        }
    }

    function endDrag(id) {
        const draggedBob = draggedItems.get(id);
        if (draggedBob) {
            draggedBob.isDragging = false;
            draggedItems.delete(id);
        }
    }

    // Mouse Events
    function mousePressed(event) {
      if (event && event.target && typeof event.target.closest === 'function' && event.target.closest('.lil-gui')) {
        return;
      }
      startAudio();
      startDrag(mouseX, mouseY, 'mouse');
      return false;
    }

    function mouseDragged(event) {
      if (event && event.target && typeof event.target.closest === 'function' && event.target.closest('.lil-gui')) {
        return;
      }
      moveDrag(mouseX, mouseY, 'mouse');
      return false;
    }

    function mouseReleased(event) {
      if (event && event.target && typeof event.target.closest === 'function' && event.target.closest('.lil-gui')) {
        return;
      }
      endDrag('mouse');
      return false;
    }

    // Touch Events for Mobile Support
    function touchStarted(event) {
      if (event && event.target && event.target.closest('.lil-gui')) {
        return true;
      }

      startAudio();
      
      let bobWasGrabbed = false;
      for (const touch of touches) {
        if (startDrag(touch.x, touch.y, touch.id)) {
          bobWasGrabbed = true;
        }
      }
      
      return !bobWasGrabbed;
    }

    function touchMoved(event) {
      if (event && event.target && event.target.closest('.lil-gui')) {
        return true;
      }
      
      let isDraggingBob = false;
      for (const touch of touches) {
        if (draggedItems.has(touch.id)) {
            moveDrag(touch.x, touch.y, touch.id);
            isDraggingBob = true;
        }
      }
      
      return !isDraggingBob;
    }

    function touchEnded(event) {
      if (event && event.target && event.target.closest('.lil-gui')) {
        return true;
      }
      
      let aDragHasEnded = false;
      const currentTouchIds = new Set(touches.map(t => t.id));
      const idsToEnd = [];

      for (const id of draggedItems.keys()) {
          if (id !== 'mouse' && !currentTouchIds.has(id)) {
              idsToEnd.push(id);
          }
      }
      
      if (idsToEnd.length > 0) {
        aDragHasEnded = true;
        idsToEnd.forEach(id => endDrag(id));
      }

      return !aDragHasEnded;
    }

    // --- Initialization & Updates ---
    
    function setupSimulation(resetPhysics = false) {
      const scaleIntervals = scales[settings.selectedScale];
      const numIntervals = scaleIntervals.length;

      // This function calculates the frequency for a bob at a given index
      const getFrequencyForIndex = (index) => {
        const octave = Math.floor(index / numIntervals);
        const noteInScale = index % numIntervals;
        const interval = scaleIntervals[noteInScale];
        const midiNote = settings.baseMidiNote + (octave * 12) + interval;
        return midiToFreq(midiNote);
      };

      if (resetPhysics) {
        // Stop and dispose of old oscillators
        for (const bob of bobs) {
          if (bob.osc) {
            bob.osc.disconnect();
            bob.osc.stop();
          }
        }
        
        bobs = [];
        springs = [];
        draggedItems.clear();

        // Dynamically calculate bob radius based on screen width
        const totalGaps = NUM_BOBS + 1;
        const availableWidthForBobs = width - (totalGaps * MIN_GAP);
        const bobDiameter = availableWidthForBobs / NUM_BOBS;
        const bobRadius = Math.max(5, bobDiameter / 2);

        for (let i = 0; i < NUM_BOBS; i++) {
          const x = MIN_GAP + bobRadius + i * (bobDiameter + MIN_GAP);
          const anchorY = height / 2;
          const freq = getFrequencyForIndex(i);

          let bob = new Bob(x, anchorY, freq, bobRadius);
          bobs.push(bob);

          let anchor = createVector(x, anchorY);
          let spring = new Spring(anchor, bob, 0);
          springs.push(spring);
        }
      } else { // Just update frequencies of existing bobs
        if (bobs.length === 0) return; // Guard against running before setup
        for (let i = 0; i < bobs.length; i++) {
          const freq = getFrequencyForIndex(i);
          if (bobs[i].osc) {
            bobs[i].osc.freq(freq);
          }
        }
      }
    }
  </script>
</body>
</html>